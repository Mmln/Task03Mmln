### Описание

#### _Внимание!!! Проект нормально загружается из GitHub в IntelliJ IDEA(Community Edition)_

1. Созданы классы Fraction, CachingHandler и Utils;
2. Создан интерфейс Fractionable;
3. Созданы аннотации @Chache и @Mutator;
4. Создано необходимое количество геттеров/сеттеров;
5. Класс UtilsOld - это вариант решения, которое я сделал и сдал в прошлом круге обучения. Сейчас оставлен для памяти;
6. Кеш реализован при помощи ConcurrentSkipListMap. Эти коллекции не требуют дополнительной синхронизации;
7. Ключ кеша заполняется временем, отсчитываемым в микросекундах (класс TimerImpl);
8. Значение кеша - Object (в файле CachingHandlerHashMap лежит вариант, где в качестве значения я использовал 
   HashMap<Method, Object>)
9. Кеш может находиться в трех состояниях:
   a) кеш пуст;
   b) кеш сброшен после вызова мутатора - есть несколько строк, но самая первая имеет ключ=0 и значение=0,
   т.к. после вызова мутатора необходимо добавить в кеш новое значение, то эта строка удаляется и добавляется
   еще одна, с новым значением кеша (такова природа коллекции ConcurrentSkipListMap);
   c) кеш в рабочем состянии - есть несколько строк, в качестве значения кеша выбирается последняя строка;
10.Параллельный процесс очистки кеша организован в классе CachingHandler как public void Process() и перед 
   запуском обернут в блок синхронизации;
11.Внутри процесса очистки кеша крутится цикл while, прерываемый значением false переменной turnOnOffThread. 
   Процесс очистки засыпает на 0.1 секунды;
12.Процесс очистки кеша останавливается при помощи вызова CachingHandler.setTurnOnOffThread(false) из основного модуля
   в конце работы основного модуля;
13.В процессе очистки кеша подсчитывается количество его вызовов;
14.Реализованы модульные тесты;
